{
  "name": "uysp-lead-processing-v3-with-field-logging",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "=kajabi-leads",
        "authentication": "headerAuth",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "1",
      "name": "Kajabi Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [100, 100],
      "webhookId": "3f7662e3-54c7-4b0e-9a12-273cd5280628",
      "credentials": {
        "httpHeaderAuth": "Header Auth account"
      }
    },
    {
      "parameters": {
        "jsCode": "const headers = $json.headers || {};\nif (headers[\"x-api-key\"] !== \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIyOWQwYWM3Ni0xYjBlLTRmMGItYTlkZC1iNzEwZDI0NzZlZmEiLCJpc3MiOiJuOG4iLCJhdWQiOiJwdWJsaWMtYXBpIiwiaWF0IjoxNzUyMDYzNTE4LCJleHAiOjE3NTk3ODgwMDB9.IRZEs36NXR6WHcZb1PiC109S70tGKsmzP86zWpun3qg\") {\n  throw new Error(\"Unauthorized\");\n}\nreturn $json.body;"
      },
      "id": "2",
      "name": "Validate API Key",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [300, 100]
    },
    {
      "parameters": {
        "jsCode": "// Smart Field Mapper - Production Code Node\n// Position: After webhook validation, before any field usage\n\n// Production approach - handle 6-8 core fields with known variations\nconst fieldMappings = {\n  // Email variations (REQUIRED - will error if not found)\n  email: ['email', 'Email', 'EMAIL', 'email_address', 'emailAddress', 'e-mail', 'contact_email'],\n  \n  // Phone variations (optional)  \n  phone: ['phone', 'Phone', 'PHONE', 'phone_number', 'phoneNumber', 'mobile', 'cell'],\n  \n  // Name variations (optional)\n  first_name: ['first_name', 'firstName', 'fname', 'given_name'],\n  last_name: ['last_name', 'lastName', 'lname', 'surname'],\n  full_name: ['name', 'Name', 'full_name', 'fullName'],\n  \n  // Business fields (optional)\n  company: ['company', 'Company', 'company_name', 'organization'],\n  title: ['title', 'Title', 'job_title', 'role', 'position'],\n  linkedin: ['linkedin', 'LinkedIn', 'linkedin_url', 'linkedinProfile']\n};\n\n// Additional fields to pass through\nconst otherFields = {\n  source_form: ['source_form', 'source', 'form_name', 'utm_source'],\n  interested_in_coaching: ['interested_in_coaching', 'coaching_interest']\n};\n\n// Initialize result\nconst normalized = {};\nconst unmappedFields = [];\nconst mappingLog = [];\n\n// Get input from webhook\nconst input = $json;\n\n// Smart mapping with case-insensitive matching\nObject.keys(fieldMappings).forEach(targetField => {\n  const variations = fieldMappings[targetField];\n  let found = false;\n  \n  // Check each variation\n  for (const variation of variations) {\n    // Case-insensitive search through input keys\n    const inputKey = Object.keys(input).find(key => \n      key.toLowerCase() === variation.toLowerCase()\n    );\n    \n    if (inputKey && input[inputKey] !== undefined && input[inputKey] !== '') {\n      normalized[targetField] = input[inputKey];\n      mappingLog.push(`Mapped ${inputKey} → ${targetField}`);\n      found = true;\n      break;\n    }\n  }\n  \n  // Set null for missing expected fields\n  if (!found && ['email', 'phone', 'company'].includes(targetField)) {\n    normalized[targetField] = null;\n    mappingLog.push(`No mapping found for ${targetField}, set to null`);\n  }\n});\n\n// Handle special case: name splitting\nif (normalized.full_name && !normalized.first_name) {\n  const parts = normalized.full_name.split(' ');\n  normalized.first_name = parts[0] || null;\n  normalized.last_name = parts.slice(1).join(' ') || null;\n  mappingLog.push(`Split full_name into first/last`);\n}\n\n// Map other fields\nObject.keys(otherFields).forEach(targetField => {\n  const variations = otherFields[targetField];\n  for (const variation of variations) {\n    const inputKey = Object.keys(input).find(key => \n      key.toLowerCase() === variation.toLowerCase()\n    );\n    if (inputKey && input[inputKey] !== undefined) {\n      normalized[targetField] = input[inputKey];\n      mappingLog.push(`Mapped ${inputKey} → ${targetField}`);\n      break;\n    }\n  }\n});\n\n// Find unmapped fields\nObject.keys(input).forEach(key => {\n  const wasMapped = mappingLog.some(log => log.includes(key));\n  if (!wasMapped) {\n    unmappedFields.push(key);\n  }\n});\n\n// Add metadata\nnormalized._mapping_metadata = {\n  original_field_count: Object.keys(input).length,\n  mapped_field_count: Object.keys(normalized).length - 1, // Exclude metadata itself\n  unmapped_fields: unmappedFields,\n  mapping_timestamp: new Date().toISOString(),\n  success_rate: (((Object.keys(normalized).length - 1) / Object.keys(input).length) * 100).toFixed(2) + '%'\n};\n\n// Pass through original fields for backward compatibility\nconst result = {\n  ...input,\n  normalized,\n  unmappedFields,\n  mappingLog,\n  original: input\n};\n\n// Check if email was found (required field)\nif (!normalized.email) {\n  throw new Error('Required field \"email\" not found in any known variations');\n}\n\nreturn result;"
      },
      "id": "smartmap",
      "name": "Smart Field Mapping",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [400, 100]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.unmappedFields.length}}",
                    "rightValue": 0,
                    "operator": {
                      "type": "number",
                      "operation": "gt"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": "Has Unmapped Fields"
            }
          ],
          "options": {
            "fallbackOutput": "No Unmapped Fields"
          }
        }
      },
      "id": "check-unmapped",
      "name": "Check for Unmapped Fields",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [600, 100]
    },
    {
      "parameters": {
        "operation": "create",
        "base": {
          "__rl": true,
          "value": "UYSP Lead Qualification",
          "mode": "list"
        },
        "table": {
          "__rl": true,
          "value": "Field_Mapping_Log",
          "mode": "list"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": [
            { "fieldId": "timestamp", "fieldValue": "={{new Date().toISOString()}}" },
            { "fieldId": "webhook_name", "fieldValue": "Kajabi Lead Webhook" },
            { "fieldId": "unknown_fields", "fieldValue": "={{$json.unmappedFields.join(', ')}}" },
            { "fieldId": "original_payload", "fieldValue": "={{JSON.stringify($json.original, null, 2)}}" },
            { "fieldId": "mapping_success_rate", "fieldValue": "={{parseFloat($json.normalized._mapping_metadata.success_rate) / 100}}" },
            { "fieldId": "reviewed", "fieldValue": false }
          ]
        },
        "options": {
          "typecast": true
        }
      },
      "id": "log-unmapped",
      "name": "Log Unmapped Fields",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [800, 50],
      "credentials": {
        "airtableTokenApi": "Airtable Personal Access Token account"
      }
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "UYSP Lead Qualification",
          "mode": "list"
        },
        "table": {
          "__rl": true,
          "value": "People",
          "mode": "list"
        },
        "filterByFormula": "=OR({email} = '{{$json.normalized.email}}', {phone_primary} = '{{$json.normalized.phone}}')",
        "options": {}
      },
      "id": "3",
      "name": "Check for Duplicates",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [1000, 100],
      "credentials": {
        "airtableTokenApi": "Airtable Personal Access Token account"
      }
    },
    {
      "parameters": {
        "jsCode": "// Check if we found any matches\nconst searchResults = $input.first().json;\nconst hasRecords = searchResults.records && searchResults.records.length > 0;\n\nif (hasRecords) {\n  // Duplicate found - prepare for update\n  const existingRecord = searchResults.records[0];\n  return {\n    duplicate: true,\n    recordId: existingRecord.id,\n    existingDuplicateCount: existingRecord.fields.duplicate_count || 0,\n    ...$input.item.json\n  };\n} else {\n  // No duplicate - prepare for create\n  return {\n    duplicate: false,\n    ...$input.item.json\n  };\n}"
      },
      "id": "4",
      "name": "Process Duplicate Check",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 100]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.duplicate}}",
                    "rightValue": true,
                    "operator": {
                      "type": "boolean",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": "Duplicate Found"
            }
          ],
          "options": {
            "fallbackOutput": "New Lead"
          }
        }
      },
      "id": "5",
      "name": "Route by Duplicate Status",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [1400, 100]
    },
    {
      "parameters": {
        "operation": "update",
        "base": {
          "__rl": true,
          "value": "UYSP Lead Qualification",
          "mode": "list"
        },
        "table": {
          "__rl": true,
          "value": "People",
          "mode": "list"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": [
            { "fieldId": "duplicate_count", "fieldValue": "={{$json.existingDuplicateCount + 1}}" },
            { "fieldId": "last_activity", "fieldValue": "={{new Date().toISOString()}}" },
            { "fieldId": "test_mode_record", "fieldValue": true }
          ],
          "matchingColumns": ["id"],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "readOnly": true
            }
          ]
        },
        "options": {
          "typecast": true,
          "bulkSize": 10
        }
      },
      "id": "6",
      "name": "Update Duplicate",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [1600, 50],
      "credentials": {
        "airtableTokenApi": "Airtable Personal Access Token account"
      }
    },
    {
      "parameters": {
        "operation": "create",
        "base": {
          "__rl": true,
          "value": "UYSP Lead Qualification",
          "mode": "list"
        },
        "table": {
          "__rl": true,
          "value": "People",
          "mode": "list"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": [
            { "fieldId": "email", "fieldValue": "={{$json.normalized.email}}" },
            { "fieldId": "first_name", "fieldValue": "={{$json.normalized.first_name}}" },
            { "fieldId": "last_name", "fieldValue": "={{$json.normalized.last_name}}" },
            { "fieldId": "phone_primary", "fieldValue": "={{$json.normalized.phone}}" },
            { "fieldId": "company_input", "fieldValue": "={{$json.normalized.company}}" },
            { "fieldId": "lead_source", "fieldValue": "={{$json.normalized.source_form}}" },
            { "fieldId": "interested_in_coaching", "fieldValue": "={{$json.normalized.interested_in_coaching === 'yes'}}" },
            { "fieldId": "request_id", "fieldValue": "={{$json.request_id || $json.normalized._mapping_metadata.mapping_timestamp}}" },
            { "fieldId": "created_date", "fieldValue": "={{new Date().toISOString()}}" },
            { "fieldId": "processing_started", "fieldValue": "={{new Date().toISOString()}}" },
            { "fieldId": "lead_status", "fieldValue": "New" },
            { "fieldId": "processing_status", "fieldValue": "Pending" },
            { "fieldId": "duplicate_count", "fieldValue": 0 },
            { "fieldId": "test_mode_record", "fieldValue": true },
            { "fieldId": "workflow_id", "fieldValue": "9VcXCYLoLpHPMmeh" }
          ]
        },
        "options": {
          "typecast": true
        }
      },
      "id": "7",
      "name": "Create New Lead",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [1600, 200],
      "credentials": {
        "airtableTokenApi": "Airtable Personal Access Token account"
      }
    },
    {
      "parameters": {
        "jsCode": "// Return success response\nconst operation = $input.item.json.duplicate ? 'updated' : 'created';\nreturn {\n  success: true,\n  operation: operation,\n  email: $input.item.json.normalized.email,\n  timestamp: new Date().toISOString(),\n  unmapped_fields_count: $input.item.json.unmappedFields.length,\n  mapping_success_rate: $input.item.json.normalized._mapping_metadata.success_rate\n};"
      },
      "id": "8",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1800, 100]
    }
  ],
  "connections": {
    "Kajabi Webhook": {
      "main": [[{"node": "Validate API Key", "type": "main", "index": 0}]]
    },
    "Validate API Key": {
      "main": [[{"node": "Smart Field Mapping", "type": "main", "index": 0}]]
    },
    "Smart Field Mapping": {
      "main": [[{"node": "Check for Unmapped Fields", "type": "main", "index": 0}]]
    },
    "Check for Unmapped Fields": {
      "main": [
        [{"node": "Log Unmapped Fields", "type": "main", "index": 0}],
        [{"node": "Check for Duplicates", "type": "main", "index": 0}]
      ]
    },
    "Log Unmapped Fields": {
      "main": [[{"node": "Check for Duplicates", "type": "main", "index": 0}]]
    },
    "Check for Duplicates": {
      "main": [[{"node": "Process Duplicate Check", "type": "main", "index": 0}]]
    },
    "Process Duplicate Check": {
      "main": [[{"node": "Route by Duplicate Status", "type": "main", "index": 0}]]
    },
    "Route by Duplicate Status": {
      "main": [
        [{"node": "Update Duplicate", "type": "main", "index": 0}],
        [{"node": "Create New Lead", "type": "main", "index": 0}]
      ]
    },
    "Update Duplicate": {
      "main": [[{"node": "Format Response", "type": "main", "index": 0}]]
    },
    "Create New Lead": {
      "main": [[{"node": "Format Response", "type": "main", "index": 0}]]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "field-normalization-v1",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "9a636351bc32ed33e9cea59b76d232bd10caf6926c3e9fa80d47901eda407040"
  },
  "id": "9VcXCYLoLpHPMmeh",
  "tags": []
}