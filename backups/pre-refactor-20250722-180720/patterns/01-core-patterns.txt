patterns/01-core-patterns.txt
Core Patterns for foundational setup, webhooks, and data handling.

Pattern: Bootstrap and Initial Setup
Purpose: Fully automate the initial setup of environment variables, tables, and sample data using commands.
Required Nodes: Code (set variables and check tables), Airtable (create sample records if needed)
Configuration:
// Node 1: Set Variables and Check Tables
Type: Code
const vars = { TEST_MODE: 'true', TEN_DLC_REGISTERED: 'false', ... }; // Full vars list from original
// Check tables and initialize
return { bootstrap_complete: true };
// Node 1.5: Initialize Daily Costs if Empty
Type: Code
const today = new Date().toISOString().split('T')[0];
const dailyCostsCheck = await $node["Airtable"].execute({
  operation: 'search',
  table: 'Daily_Costs',
  filterByFormula: `{date} = '${today}'`
});
if (dailyCostsCheck.length === 0) {
  await $node["Airtable"].execute({
    operation: 'create',
    table: 'Daily_Costs',
    fields: {
      date: today,
      initial_total: 0,
      apollo_org_costs: 0,
      apollo_people_costs: 0,
      twilio_costs: 0,
      sms_costs: 0,
      total_costs: 0
    }
  });
}
return { daily_costs_initialized: true };
// Node 2: Create Sample Records
Type: Airtable
Operation: Create
Table: People
Fields: { email: 'sample@example.com', ... }
Error Handling: console.error('Bootstrap failed for table');

Pattern: Field Normalization (MANDATORY)
Purpose: Normalize all incoming webhook fields to handle chaos in external form field names. Prevents silent data loss and ensures all downstream nodes use a stable schema.
Required Nodes: Code (Smart Field Mapper)
Configuration:
// Node: Smart Field Mapper (Code)
// Place immediately after webhook validation, before any field usage
const fieldMappings = {
  email: ['email', 'Email', 'EMAIL', 'email_address', 'emailAddress', 'e-mail', 'contact_email'],
  phone: ['phone', 'Phone', 'PHONE', 'phone_number', 'phoneNumber', 'mobile', 'cell'],
  first_name: ['first_name', 'firstName', 'fname', 'given_name'],
  last_name: ['last_name', 'lastName', 'lname', 'surname'],
  full_name: ['name', 'Name', 'full_name', 'fullName'],
  company: ['company', 'Company', 'company_name', 'organization'],
  title: ['title', 'Title', 'job_title', 'role', 'position'],
  linkedin: ['linkedin', 'LinkedIn', 'linkedin_url', 'linkedinProfile']
};
const otherFields = {
  source_form: ['source_form', 'source', 'form_name', 'utm_source'],
  interested_in_coaching: ['interested_in_coaching', 'coaching_interest']
};
const normalized = {};
const unmappedFields = [];
const mappingLog = [];
const input = $input.item.json;
Object.keys(fieldMappings).forEach(targetField => {
  const variations = fieldMappings[targetField];
  let found = false;
  for (const variation of variations) {
    const inputKey = Object.keys(input).find(key => key.toLowerCase() === variation.toLowerCase());
    if (inputKey && input[inputKey] !== undefined && input[inputKey] !== '') {
      normalized[targetField] = input[inputKey];
      mappingLog.push(`Mapped ${inputKey} → ${targetField}`);
      found = true;
      break;
    }
  }
  if (!found && ['email', 'phone', 'company'].includes(targetField)) {
    normalized[targetField] = null;
    mappingLog.push(`No mapping found for ${targetField}, set to null`);
  }
});
if (normalized.full_name && !normalized.first_name) {
  const parts = normalized.full_name.split(' ');
  normalized.first_name = parts[0] || null;
  normalized.last_name = parts.slice(1).join(' ') || null;
  mappingLog.push(`Split full_name into first/last`);
}
Object.keys(input).forEach(key => {
  const wasMapped = mappingLog.some(log => log.includes(key));
  if (!wasMapped) {
    unmappedFields.push(key);
  }
});
normalized._mapping_metadata = {
  original_field_count: Object.keys(input).length,
  mapped_field_count: Object.keys(normalized).length,
  unmapped_fields: unmappedFields,
  mapping_timestamp: new Date().toISOString(),
  success_rate: ((Object.keys(normalized).length / Object.keys(input).length) * 100).toFixed(2) + '%'
};
if (unmappedFields.length > 0) {
  console.log('Unknown fields detected:', unmappedFields);
  // In production: Send to error log table
}
return {
  normalized,
  unmappedFields,
  mappingLog,
  original: input
};
Integration:
- Add after webhook validation
- Update all downstream nodes to use normalized fields (e.g., {{$json.normalized.email}})
- Log unmapped fields for monitoring
- Weekly review of logs required
- Test with all payloads in test-suite.json

Pattern: Test Mode Enforcement
Purpose: Prevent accidental SMS sends and API calls during development/testing
Required Nodes: Code (check test mode), Switch (route based on mode)
Configuration:
// Node 1: Check Test Mode
Type: Code
const TEST_MODE = $vars.TEST_MODE === 'true';
if (TEST_MODE) { return { test_mode: true, ... }; }
// Node 2: Route by Mode
Type: Switch
Rules: test_mode = true → Log Only
Error Handling: In SMS nodes - if test_mode, log and simulate success.

Pattern: Webhook Authentication with Duplicate Prevention
Purpose: Secure webhook reception with header-based authentication and duplicate request prevention
Required Nodes: Webhook (trigger), Code (validation + duplicate check), Airtable (check request_id), Switch (route duplicates)
Configuration:
// Node 1: Webhook
Type: Webhook
Settings: HTTP Method: POST, Path: /webhook/[endpoint-name], Authentication: Header Auth (X-API-Key)
// Node 2: Validate and Generate Request ID
Type: Code
const request_id = ...; // Generate or extract
// Node 3: Check Request Already Processed
Type: Airtable
Filter by Formula: OR({request_id} = '{{$json.request_id}}', ...)
// Node 4: Skip if Duplicate
Type: Switch
Error Handling: Return 200 for duplicates, 400 for validation errors.

Pattern: Airtable Upsert with Multiple Match Logging
Purpose: Create or update records based on unique identifier with logging for data integrity
Required Nodes: Airtable (search), Code (log multiples), Switch (route), Airtable (create/update), Merge
Configuration:
// Node 1: Search Existing
Type: Airtable
Filter by Formula: OR({email} = '{{$json.email}}', ...)
// Node 2: Check and Log Multiple Matches
Type: Code
if (matches.length > 1) { console.warn('Multiple records found'); }
// Node 3: Route Decision
Type: Switch
// Nodes 4A/B: Create/Update
Error Handling: Retry On Fail: true, Max Tries: {{$vars.MAX_RETRIES}}

Pattern: Batch Processing with Memory Safety
Purpose: Process large datasets without overwhelming memory or APIs
Required Nodes: Airtable (get batch), Code (chunk data), Loop (process chunks), Wait, Airtable (update)
Configuration:
// Node 1: Get Batch
Type: Airtable
Max Records: {{$vars.BATCH_SIZE}}
// Node 2: Chunk and Validate Size
Type: Code
const chunks = []; // Create chunks
// Node 3: Process Loop
Type: Loop Over Items
Error Handling: Console log memory warnings.

Pattern: Complete Lead Processing Flow
Purpose: Connect all patterns into a complete working workflow
Required Nodes: All patterns connected in sequence
Configuration: MAIN WORKFLOW: uysp-lead-processing-v1
Webhook Receiver → Test Mode Check → ... → SMS Campaign
Error Handling: Each step continues on error for non-critical failures.

Pattern: Workflow ID Helper
Purpose: Centralized workflow ID management and lookup
Required Nodes: Code (ID lookup helper)
Configuration:
// Node 1: Workflow ID Helper
Type: Code
async function getWorkflowId(workflowName) { ... } // From env or Airtable
Error Handling: Throw if not found.